/** @enum {string} */
var c3d_resources={
"common_frag":"uniform mat4 uProjectionMatrix;\n\nvec3 sphere(in vec3 ray,in vec3 center,in float radius,in float face){\n\nvec3 dir=normalize(ray);\n\n\n\n\nfloat b=dot(center,dir);\nfloat c=dot(center,center) -radius*radius;\nfloat d=b*b-c;\nif(d<0.0)discard;\nfloat lambda=b+face*sqrt(d);\nif(lambda<0.0)discard;\n\n\nreturn lambda*dir;\n}\n\nvoid finish(in vec3 pos,in vec3 normal){\nshade(pos,normal);\n#ifdef GL_EXT_frag_depth\nvec4 projPoint=uProjectionMatrix*vec4(pos,1);\ngl_FragDepthEXT= (projPoint.z/projPoint.w+1.0) /2.0;\n#endif\n#ifdef webgl2\nvec4 projPoint=uProjectionMatrix*vec4(pos,1);\ngl_FragDepth= (projPoint.z/projPoint.w+1.0) /2.0;\n#endif\n}\n",
"cylinder_frag":"varying vec3 vPoint1;\n\nvarying vec3 vPoint2;\n\nvarying vec3 vPos;\n\nvarying float vRadius;\n\nvec3 endcaps(in float mu,inout vec3 pos){\nvec3 center;\nif(mu<0.0){\ncenter=vPoint1;\n}else if(mu>1.0){\ncenter=vPoint2;\n}else{\nreturn(1.0-mu)*vPoint1+mu*vPoint2;\n}\npos=sphere(vPos,center,vRadius, -1.0);\nreturn center;\n}\n\n\n\n\nvoid main(){\ngColor=vColor;\n\n\n\nvec3 ba=vPoint2-vPoint1;\nvec3 u=ba/dot(ba,ba);\nvec3 v=vPos-dot(vPos,ba)*u;\nvec3 w=dot(vPoint1,ba)*u-vPoint1;\nfloat a=dot(v,v);\nfloat b=2.0*dot(v,w);\nfloat c=dot(w,w) -vRadius*vRadius;\nfloat d=b*b-4.0*a*c;\nif(d<0.0)\ndiscard;\nfloat lambda= (b+sqrt(d))/(-2.0*a);\nvec3 pointOnSurface=lambda*vPos;\nfloat mu=dot(pointOnSurface-vPoint1,u);\nvec3 center=endcaps(mu,pointOnSurface);\nvec3 normal=normalize(pointOnSurface-center);\nfinish(pointOnSurface,normal);\n}\n",
"cylinder_vert":"uniform mat4 uProjectionMatrix;\n\nuniform mat4 uModelViewMatrix;\n\nattribute vec4 aPoint1;\n\nattribute vec4 aPoint2;\n\nattribute vec4 aColor;\n\nattribute vec4 aRelativeRadius;\n\nattribute vec4 aShininess;\n\nvarying vec3 vPoint1;\n\nvarying vec3 vPoint2;\n\nvarying vec3 vPos;\n\nvarying vec4 vColor;\n\nvarying float vRadius;\n\n\n\n\nvoid main(){\n\nvec4 hom;\nhom=uModelViewMatrix*aPoint1;\nvPoint1=hom.xyz/hom.w;\nhom=uModelViewMatrix*aPoint2;\nvPoint2=hom.xyz/hom.w;\nvec3 dir=normalize(vPoint2-vPoint1);\n\n\nvec3 d2,d3;\nif(abs(dir.x) <abs(dir.y))\nd2=vec3(1,0,0);\nelse\nd2=vec3(0,1,0);\nd2=normalize(cross(dir,d2));\nd3=normalize(cross(dir,d2));\n\nvPos=aRelativeRadius.w*(mat3(dir,d2,d3)*aRelativeRadius.xyz)\n+0.5*((vPoint2+vPoint1) +aRelativeRadius.x*(vPoint2-vPoint1));\n\n\nvColor=aColor;\nvShininess=aShininess.x;\nvSpecularReflectiveness= (1.0-pow(0.95,vShininess));\nvRadius=aRelativeRadius.w;\n\n\ngl_Position=uProjectionMatrix*vec4(vPos,1);\n}\n",
"lighting1":"uniform vec3 uAmbient;\nuniform mat4 uModelViewMatrix;\n\nvarying vec4 vColor;\nvarying float vShininess;\nvarying float vSpecularReflectiveness;\n\nvec4 gColor;\nvec3 gPos;\nvec3 gEye;\nvec3 gNormal;\nvec3 gAccumDiffuse;\nvec3 gAccumSpecular;\n\nvoid commonLight(in vec4 lightPos,out vec3 lightDir,\nout float diffuseFactor,out float specularFactor){\nvec3 halfVector;\nfloat specularDot;\n\nlightDir=normalize(lightPos.xyz-lightPos.w*gPos);\nhalfVector=normalize(lightDir+gEye);\ndiffuseFactor=max(0.0,dot(gNormal,lightDir));\nspecularDot=max(0.0,dot(gNormal,halfVector));\n\n\nif(diffuseFactor==0.0)\nspecularFactor=0.0;\nelse\nspecularFactor=pow(specularDot,vShininess) *vSpecularReflectiveness;\n}\n\nvec4 flipY(in vec4 v){\nreturn vec4(v.x, -v.y,v.z,v.w);\n}\n\nvoid pointLight(in vec4 lightPos,in vec3 diffuse,in vec3 specular){\nvec3 lightDir;\nfloat diffuseFactor;\nfloat specularFactor;\n\ncommonLight(lightPos,lightDir,diffuseFactor,specularFactor);\n\n\ngAccumDiffuse +=diffuse*diffuseFactor;\ngAccumSpecular+=specular*specularFactor;\n}\n\nvoid cameraPointLight(in vec4 lightPos,in vec3 diffuse,in vec3 specular){\npointLight(flipY(lightPos),diffuse,specular);\n}\n\nvoid worldPointLight(in vec4 lightPos,in vec3 diffuse,in vec3 specular){\npointLight(-uModelViewMatrix*lightPos,diffuse,specular);\n}\n\nvoid spotLight(\nin vec4 lightPos,in vec4 spotPos,in float spotCosCutoff,\nin float spotExponent,in vec3 diffuse,in vec3 specular)\n{\nvec3 lightDir;\nfloat diffuseFactor;\nfloat specularFactor;\nvec3 spotDir;\nfloat spotCosAngle;\nfloat spotAttenuation;\n\ncommonLight(lightPos,lightDir,diffuseFactor,specularFactor);\n\nspotDir=lightPos.w*spotPos.xyz-spotPos.w*lightPos.xyz;\nspotCosAngle=dot(-lightDir,normalize(spotDir));\nspotAttenuation=\nstep(spotCosCutoff,spotCosAngle) *pow(spotCosAngle,spotExponent);\n\n\ngAccumDiffuse +=spotAttenuation*diffuse*diffuseFactor;\ngAccumSpecular+=spotAttenuation*specular*specularFactor;\n}\n\nvoid cameraSpotLight(\nin vec4 lightPos,in vec4 spotPos,in float spotCosCutoff,\nin float spotExponent,in vec3 diffuse,in vec3 specular)\n{\nspotLight(\nflipY(lightPos),flipY(spotPos),\nspotCosCutoff,spotExponent,diffuse,specular);\n}\n\nvoid worldSpotLight(\nin vec4 lightPos,in vec4 spotPos,in float spotCosCutoff,\nin float spotExponent,in vec3 diffuse,in vec3 specular)\n{\nspotLight(\n-uModelViewMatrix*lightPos, -uModelViewMatrix*spotPos,\nspotCosCutoff,spotExponent,diffuse,specular);\n}\n",
"lighting2":"\n\n\n\n\n\nvoid shade(in vec3 position,in vec3 normal){\n\ngAccumDiffuse=vec3(0.0);\ngAccumSpecular=vec3(0.0);\n\n\ngPos=position;\ngEye= -normalize(position);\ngNormal=sign(dot(gEye,normal))*normal;\n\n\nlightScene();\n\n\n\nvec3 color= (uAmbient+gAccumDiffuse) *gColor.xyz\n+gAccumSpecular;\n\ncolor=clamp(color,0.0,1.0);\ngl_FragColor=vec4(color.xyz,gColor.w);\n}\n",
"sphere_frag":"\nuniform float sphereMode;\n\n\nvarying vec3 vViewSpacePos;\n\nvarying vec3 vViewSpaceCenter;\n\nvarying float vRadius;\n\n\n\n\nvoid main(){\ngColor=vColor;\nvec3 pointOnSphere=\nsphere(vViewSpacePos,vViewSpaceCenter,vRadius,sphereMode);\nvec3 normal=normalize(pointOnSphere-vViewSpaceCenter);\nfinish(pointOnSphere,normal);\n}\n",
"sphere_vert":"uniform mat4 uProjectionMatrix;\n\nuniform mat4 uModelViewMatrix;\n\nattribute vec4 aCenter;\n\nattribute vec4 aColor;\n\nattribute vec4 aRelativeShininessRadius;\n\nvarying vec3 vViewSpacePos;\n\nvarying vec3 vViewSpaceCenter;\n\nvarying vec4 vColor;\n\nvarying float vRadius;\n\n\n\n\nvoid main(){\n\nvec4 viewPosHom=uModelViewMatrix*aCenter;\nvViewSpaceCenter=viewPosHom.xyz/viewPosHom.w;\nvec3 dir=normalize(-vViewSpaceCenter);\nvec3 right=normalize(cross(dir,vec3(0,1,0)));\nvec3 up=normalize(cross(right,dir));\n\n\nvColor=aColor;\nvShininess=aRelativeShininessRadius.z;\nvSpecularReflectiveness= (1.0-pow(0.95,vShininess));\nvRadius=aRelativeShininessRadius.w;\n\n\nvViewSpacePos=vViewSpaceCenter+\nvRadius*(right*aRelativeShininessRadius.x+\nup*aRelativeShininessRadius.y+dir);\n\n\ngl_Position=uProjectionMatrix*vec4(vViewSpacePos,1);\n}\n",
"texq_frag":"precision highp float;\n\nuniform sampler2D uTexture;\nvarying vec2 vPos;\n\nvoid main(){\ngl_FragColor=texture2D(uTexture,vPos);\n}\n",
"texq_vert":"precision highp float;\n\nattribute vec4 aPos;\nvarying vec2 vPos;\n\nvoid main(){\nvPos=aPos.zw;\ngl_Position=vec4(aPos.xy,0,1);\n}\n",
"triangle_frag":"varying vec4 vPos;\nvarying vec4 vNormal;\n\nuniform bool uTextured;\nuniform sampler2D uTexture;\n\nvoid main(){\nif(uTextured)\ngColor=texture2DProj(uTexture,vColor.xyz);\nelse\ngColor=vColor;\nfinish(vPos.xyz/vPos.w,normalize(vNormal.xyz));\n}\n",
"triangle_vert":"uniform mat4 uProjectionMatrix;\nuniform mat4 uModelViewMatrix;\n\nattribute vec4 aPos;\nattribute vec4 aNormalAndShininess;\nattribute vec4 aColor;\n\nvarying vec4 vPos;\nvarying vec4 vNormal;\nvarying vec4 vColor;\n\nvoid main(){\nvPos=uModelViewMatrix*aPos;\ngl_Position=uProjectionMatrix*vPos;\nvNormal=uModelViewMatrix*vec4(aNormalAndShininess.xyz,0.0);\nvShininess=aNormalAndShininess.w;\nvSpecularReflectiveness= (1.0-pow(0.95,vShininess));\nvColor=aColor;\n}\n"
};